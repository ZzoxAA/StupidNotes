### 随手记

##### Python `@property`

Python里@property的实现与[官方文档](https://docs.python.org/3/howto/descriptor.html#properties)给出的模拟实现有些细微的差别。在property的实现中初始化的时候会将属性（也就是被@property装饰的函数）作为默认的setter实现。代码如下：

```python
class Cls：
	def pro(self):
        pass
    print('the function "pro": ', pro)
    pro = property(pro)	#等同于用@property装饰pro
    print('the property "pro": ', pro)
    print('fget of property "pro": ', pro.fget)
    print('fset of property "pro": ', pro.fset)
    
    @pro.getter
    def pro(self):
        return self.foo
	@pro.setter
    def pro(self, value)
    	self.foo = value
    print('fget of property "pro": ', pro.fget)
    print('fset of property "pro": ', pro.fset)

print(Cls.pro)
```

可以看出在被`@property`装饰（也就是我们显示地调用`pro = property(pro)`）前后，**pro**和**pro.fset**是同一个函数。

- **property**初始化的时候就拥有了**\_\_set\_\_**、**\_\_get\_\_**、**\_\_delete\_\_**方法，所以**property**永远是一个*data descriptor*，我们显示包装的**setter**、**getter**、**deleter**等方法会被蕴含在**property**本身的**\_\_set\_\_**、**\_\_get\_\_**、**\_\_delete\_\_**方法当中在适当的时机被自动调用（但不总是会被调用，看下一点）。

- 直接读取类的属性会返回属性本身，不会调用我们显示包装的**setter**。

- `@property` `@pro.setter(or getter or deleter)`返回的都是 `property`类型，相当于只是在更新**property**的一些实例变量。所以`@pro.setter(or getter or deleter)`装饰的方法都应该和被`@property`装饰的方法同名。

- ```python
  @decorator 
  def fn(...)：
  	pass
  ```

   等同于 `fn = decorator(fn)`。

- 属性中实际变量存在于各个实例的字典中，即`instance.__dict__`。

