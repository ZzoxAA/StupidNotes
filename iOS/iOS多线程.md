### iOS多线程

##### 并发/串行队列

​		队列的并发和串行决定了队列中的任务是否进入新创建的进程（如果有新的进程被创建）。对于串行队列来说，必须等待上一个任务执行结束之后才能派发新的任务到线程。对于并发队列来说，有新的进程被创建时，队列里的任务会被派发给新的线程而无需等待队列里的上一个任务执行结束。

##### 同步/异步执行

​		同步异步执行决定了任务是否创建新的线程。（主队列中的异步执行比较特殊，无法创建新的线程，猜想主队列中的任务只能在主线程中执行，待验证：在一个子线程中向主线程添加异步任务【已验证，无法创建新的线程】，但是其本质原因似乎是因为不能给一个正在占有线程的串行队列创建新的线程【已验证：一个新的串行队列添加同步任务占有主线程，然后在同步任务中向该串行队列添加异步任务不会创建新的线程，然后主线程会被还给主队列继续进行被阻塞的任务，此时主队列占有主线程，新的串行队列当中还未执行的异步任务会寻找空闲的线程，如果没有空闲的线程，异步任务将会创建新的线程然后占有该线程一直执行下去。【已验证：在上一个验证中的同步任务中向串行队列添加大量的异步任务，这些异步任务会开启一个（且仅有一个）新的线程去执行】）；同时串行队列当中的异步任务还决定了是否抢占CPU资源（即异步任务只在CPU任务空闲时执行，即串行队列中的其他同步任务已经完成）。同步任务的创建会导致当前线程的阻塞（这一点非常重要），所以说同步任务要么是在执行当中；要么是被其他队列当中的新的同步任务阻塞；要么是是被当前队列中新的同步阻塞导致思索。即关键的一点是在于同步任务的创建要求其马上执行，所以同步任务永远不会排队堆集，而异步任务会排队且等待CPU资源空闲再执行。

##### 关键点

​		所有的线程性质都是一样的，没有同步异步线程一说，GCD的本质在于能否创建新的线程和队列中的任务进入线程的方式。线程的创建似乎是和队列呈现绑定关系，即使有空余线程其他无关队列也不能使用，此结论待验证。

##### 杂项

​		主线程的销毁会导致所有子线程的销毁，在iOS App开发中一般不会涉及到，App的主线程永远不会销毁。

##### 总结

1. 所有线程是平等且性质相同。
2. 同步任务立即阻塞当前线程并执行。

2. 如果可以（参考3），异步任务总是创建新的线程并执行。
3. 占有了一个线程的串行队列（即任务正在被执行的串行队列），会阻止异步任务创建新的线程。（这个结论可以解释为什么主线程添加异步任务不会创建新的线程而串行队列会，而不是因为"主队列的任务只能在主线程执行"这个表象原因）。
4. 由2、3可知，当一个串行队列没有占有任何线程且拥有未完成的异步任务时候，且系统没有任何空闲线程，任务会在新的线程上被执行。
5. 异步任务总是等待线程中被阻塞的任务（此种情况下可能导致一个队列被迫放弃正在占有的线程而将线程释放给被阻塞任务所在的队列）。

##### more

​		源码。

