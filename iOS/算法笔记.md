# 算法笔记

## 单调栈思路

单调递增：栈中实际上维护的是当前序列的从最小元素开始的最小间隙递增子序列。

最小间隙指栈中两个相邻元素保存了序列中的两个索引`i,j`，假设`i<j`；即`list[j] - list[i]`的值是`list[k] - list[i]`中最小的，其中`k`是任意大于`i`的整数。

单调递减：栈中实际上维护的是当前序列的从最大元素开始的最小间隙递减子序列。

*单调栈特别适合解决那些，两头大小决定中间值的大小的题。*

思路实际上就是把问题转换成**两头大小决定中间值的大小**的问题。

比如LeetCode中的[面积问题](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)，可以变为求每块木板能完全往左右延伸的最远距离，即左边第一个比他小的和右边第一个比他小的。

##### 动态规划	

dp三大特点：

- **最优子结构**
- **重叠子问题**
- **状态转移方程**

dp优化技巧：

- 『**状态压缩**』，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

dp数组遍历方向共同点：

1. **遍历的过程中，所需的状态必须是已经计算出来的**。
2. **遍历的终点必须是存储结果的那个位置**。

## 二叉树迭代遍历

对于递归来说，无论前中后哪种顺序遍历，递归的过程中**每个节点所处栈帧进出顺序都是相同的**。所以说迭代的时候遵循递归时的栈帧进出的顺序即可。

对于**前序**和**中序**遍历来说，在模拟左子树返回其根节点的时候，此时已经获取到根节点的右子树，而根节点要么在入栈的时候访问过了(前序)，要么在此时访问（中序），由于根节点已经访问且其左右子树节点都已经获取到，所以为了避免根节点对迭代的影响，此时根节点已经可以出栈，并不影响我们对栈帧过程的模拟，只是相当于略过了每个递归函数体运行完之后出栈的过程。

**后续**遍历则是完全模拟递归的栈帧行为。

**前序遍历**

```c++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    TreeNode *node = root;
    while(node || !st.empty()){
        while(node){
            res.push_back(node->val);
            st.push(node);
            node = node->left;
        }
        node = st.top();
        st.pop();
        node = node->right;
    }
    return res;
}
```

**中序遍历**

```c++
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;	
    TreeNode *node = root;
    while(node || !st.empty()){
        while(node){
            st.push(node);
            node = node->left;
        }
        node = st.top();
        st.pop();
        res.push_back(node->val);
        node = node->right;
    }
    return res;
}
```

**后续遍历**

```c++
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    TreeNode *node = root;
    //last不赋初值可能会导致last == node->right条件在极小的可能下成真，初值赋root或者nullptr都可行
    TreeNode *last = root;
    while (node || !st.empty()) {
        while (node) {
            st.push(node);
            node = node->left;
        }
        node = st.top();
        if (!node->right || last == node->right) {
            res.push_back(node->val);
            st.pop();
            last = node;
            //表示当前节点的左右子树以及自身都已处理完毕，在栈帧中即是当前递归函数体返回，退出栈帧，程序运行需要继续弹出栈			 帧做处理
            node = nullptr;
        }else {
            node = node->right;
        }
    }
    return res;
}
```

**另一个版本的迭代遍历，使用nullptr辅助，形式更具有统一性**

```c++
//先序遍历： 
vector<int> preorderTraversal(TreeNode* root) {
    if(!root) return {};
    vector<int> result;
    stack<TreeNode*> stk;
    stk.push(root);
    while(!stk.empty()){
        TreeNode* node = stk.top();
        stk.pop();
        if(node){
            if(node -> right){
                stk.push(node -> right);
            }
            if(node -> left){
                stk.push(node -> left);
            } 
            stk.push(node);
            stk.push(nullptr);
        }else{
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
//中序遍历：
vector<int> inorderTraversal(TreeNode* root) {
    if(!root) return {};
    vector<int> result;
    stack<TreeNode*> stk;
    stk.push(root);
    while(!stk.empty()){
        TreeNode* node = stk.top();
        stk.pop();
        if(node){
            if(node -> right){
                stk.push(node -> right);
            }
            stk.push(node);
            stk.push(nullptr);
            if(node -> left){
                stk.push(node -> left);
            } 
        }else{
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}

//后序遍历：
vector<int> postorderTraversal(TreeNode* root) {
    if(!root) return {};
    vector<int> result;
    stack<TreeNode*> stk;
    stk.push(root);
    while(!stk.empty()){
        TreeNode* node = stk.top();
        stk.pop();
        if(node){
            stk.push(node);
            stk.push(nullptr);
            if(node -> right){
                stk.push(node -> right);
            }
            if(node -> left){
                stk.push(node -> left);
            } 
        }else{
            result.push_back(stk.top()->val);
            stk.pop();
        }
    }
    return result;
}
```



对于N叉树来说，转换思路，因为N叉树没有办法从子节点在回到父节点时确定哪个子节点进栈(二叉树永远是右节点进栈)。

## tips & cautions

- 数组元素的值和数组index同时作为判断条件时一定要先判断数组index然后再判断数组元素值，防止越界访问。`index is 合法 && vector[index] is 合法`