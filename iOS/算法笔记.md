### 算法笔记

##### 单调栈思路

单调递增：栈中实际上维护的是当前序列的从最小元素开始的最小间隙递增子序列。

最小间隙指栈中两个相邻元素保存了序列中的两个索引`i,j`，假设`i<j`；即`list[j] - list[i]`的值是`list[k] - list[i]`中最小的，其中`k`是任意大于`i`的整数。

单调递减：栈中实际上维护的是当前序列的从最大元素开始的最小间隙递减子序列。

*单调栈特别适合解决那些，两头大小决定中间值的大小的题。*

思路实际上就是把问题转换成**两头大小决定中间值的大小**的问题。

比如LeetCode中的[面积问题](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)，可以变为求每块木板能完全往左右延伸的最远距离，即左边第一个比他小的和右边第一个比他小的。

##### 动态规划	

dp三大特点：

- **最优子结构**
- **重叠子问题**
- **状态转移方程**

dp优化技巧：

- 『**状态压缩**』，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

dp数组遍历方向共同点：

1. **遍历的过程中，所需的状态必须是已经计算出来的**。
2. **遍历的终点必须是存储结果的那个位置**。

##### 二叉树迭代遍历

对于递归来说，无论前中后哪种顺序遍历，递归的过程中栈帧都是相同的，即`一直进左节点直到空—>回退到上一个父节点所在栈帧—>右节点进入栈帧—>回退到上一个父节点栈帧—>回退到上一个父节点栈帧`如此往复。所以说迭代的时候遵循递归时的栈帧进出的顺序即可。

**前序遍历**

```c++

```

**先序遍历**

```c++

```

**后续遍历**

```c++

```

**另一个版本的迭代遍历，使用nullptr辅助，形式更具有统一性**

```c++
//先序遍历： 
    vector<int> preorderTraversal(TreeNode* root) {
        if(!root) return {};
        vector<int> result;
        stack<TreeNode*> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode* node = stk.top();
            stk.pop();
            if(node){
                if(node -> right){
                    stk.push(node -> right);
                }
                if(node -> left){
                    stk.push(node -> left);
                } 
                stk.push(node);
                stk.push(nullptr);
            }else{
                result.push_back(stk.top()->val);
                stk.pop();
            }
        }
        return result;
    }
//中序遍历：
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root) return {};
        vector<int> result;
        stack<TreeNode*> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode* node = stk.top();
            stk.pop();
            if(node){
                if(node -> right){
                    stk.push(node -> right);
                }
                stk.push(node);
                stk.push(nullptr);
                if(node -> left){
                    stk.push(node -> left);
                } 
            }else{
                result.push_back(stk.top()->val);
                stk.pop();
            }
        }
        return result;
    }

//后序遍历：
    vector<int> postorderTraversal(TreeNode* root) {
        if(!root) return {};
        vector<int> result;
        stack<TreeNode*> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode* node = stk.top();
            stk.pop();
            if(node){
                stk.push(node);
                stk.push(nullptr);
                if(node -> right){
                    stk.push(node -> right);
                }
                if(node -> left){
                    stk.push(node -> left);
                } 
            }else{
                result.push_back(stk.top()->val);
                stk.pop();
            }
        }
        return result;
    }
```



对于N叉树来说，转换思路，因为N叉树没有办法从子节点在回到父节点时确定哪个子节点进栈(二叉树永远是右节点进栈)。