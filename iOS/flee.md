# Flee

[TOC]



## C/C++

#### 虚函数

###### 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？

将可能会被继承的**父类的析构函数**设置为**虚函数**，可以保证当我们 new 一个子类，然后使用**基类指针指向**该**子类对象**，释放基类指针时可以**释放子类的空间**，**防止内存泄漏**。

C++默认的析构函数不是虚函数是因为**虚函数**需要额外的**虚函数表**和虚表指针，占用**额外内存**。而对于**不会被继承的类**来说，其析构函数如果是虚函数，就会浪费内存。因此 C++ 默认的析构函数不是虚函数，而是**只有当需要当作父类时，设置为虚函数**。

###### 类析构顺序：

1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。

###### 静态函数和虚函数的区别：

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

###### 请你说一说你理解的虚函数和多态

多态的实现主要分为**静态多态**和**动态多态**，静态多态主要是**重载**，在**编译期**决定；动态多态是用**虚函数**机制实现的，在**运行期**间动态绑定。

###### 虚函数的实现：

在有虚函数的类中，类的最开始部分是一个**指向虚函数表的指针**，表中放了虚函数的地址，**实际的虚函数在代码段(.text)中**。当子类继承了父类的时候也会**继承其虚函数表**，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加内存开销，降低访问效率。

#### static 关键字

1. 修饰**普通变量**，修改变量的存储区域和生命周期，使变量存储在**静态区**，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值**系统**用**默认值初始化**它。
2. 修饰普通函数，表明函数的作用范围，**仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰**成员变量**，修饰成员变量使所有的对象只保存一个该变量，而且**不需要生成对象就可以访问该成员**。
4. 修饰**成员函数**，修饰成员函数使得**不需要生成对象就可以访问该函数**，但是在 static 函数内**不能访问非静态成员**。

#### this 指针

1. `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数(即**常成员函数**)中，`this` 指针的类型为：`const ClassName* const this`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用 `this` 指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。

###### volatile 关键字

`volatile` 是一种**类型修饰符**，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以**提供特殊地址进行稳定的访问**。

`volatile`用在如下的几个地方：

1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；

2) **多任务环境**下各任务间**共享的标志**应该加volatile；

3) **存储器映射的硬件寄存器**通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

###### sizeof() 运算符

- `sizeof` 对数组，得到整个数组所占空间大小。
- `sizeof` 对指针，得到指针本身所占空间大小，根据 32/64 位系统决定。

###### C 实现 C++ 类

C 实现 C++ 的面向对象特性（封装、继承、多态）

- 封装：使用**函数指针**把属性与方法封装到结构体中
- 继承：**结构体嵌套**
- 多态：父类与子类方法的函数指针不同

## Caution & Tips

- [ ] 看一下 struct 写法，尤其构造函数和初始化列表，为了手写 struct 做准备。
- [ ] 记住万能头文件 `include<bits/stdc++.h>`。

