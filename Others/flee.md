# Flee

[TOC]



## C/C++

#### 虚函数

###### 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？

将可能会被继承的**父类的析构函数**设置为**虚函数**，可以保证当我们 new 一个子类，然后使用**基类指针指向**该**子类对象**，释放基类指针时可以**释放子类的空间**，**防止内存泄漏**。

C++默认的析构函数不是虚函数是因为**虚函数**需要额外的**虚函数表**和虚表指针，占用**额外内存**。而对于**不会被继承的类**来说，其析构函数如果是虚函数，就会浪费内存。因此 C++ 默认的析构函数不是虚函数，而是**只有当需要当作父类时，设置为虚函数**。

###### 类析构顺序：

1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。

###### 静态函数和虚函数的区别：

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

###### 请你说一说你理解的虚函数和多态

多态的实现主要分为**静态多态**和**动态多态**，静态多态主要是**重载**，在**编译期**决定；动态多态是用**虚函数**机制实现的，在**运行期**间动态绑定。

###### 虚函数的实现：

在有虚函数的类中，类的最开始部分是一个**指向虚函数表的指针**，表中放了虚函数的地址，**实际的虚函数在代码段(.text)中**。当子类继承了父类的时候也会**继承其虚函数表**，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加内存开销，降低访问效率。

#### static 关键字

1. 修饰**普通变量**，修改变量的存储区域和生命周期，使变量存储在**静态区**，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值**系统**用**默认值初始化**它。
2. 修饰普通函数，表明函数的作用范围，**仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰**成员变量**，修饰成员变量使所有的对象只保存一个该变量，而且**不需要生成对象就可以访问该成员**。
4. 修饰**成员函数**，修饰成员函数使得**不需要生成对象就可以访问该函数**，但是在 static 函数内**不能访问非静态成员**。

#### this 指针

1. `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数(即**常成员函数**)中，`this` 指针的类型为：`const ClassName* const this`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用 `this` 指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。

###### volatile 关键字

`volatile` 是一种**类型修饰符**，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以**提供特殊地址进行稳定的访问**。

`volatile`用在如下的几个地方：

1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；

2) **多任务环境**下各任务间**共享的标志**应该加volatile；

3) **存储器映射的硬件寄存器**通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

###### sizeof() 运算符

- `sizeof` 对数组，得到整个数组所占空间大小。
- `sizeof` 对指针，得到指针本身所占空间大小，根据 32/64 位系统决定。

###### C 实现 C++ 类

C 实现 C++ 的面向对象特性（封装、继承、多态）

- 封装：使用**函数指针**把属性与方法封装到结构体中
- 继承：**结构体嵌套**
- 多态：父类与子类方法的函数指针不同

###### friend 友元类和友元函数

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制

###### enum 枚举类型

`enum class open_modes { input, output, append };`限定作用域。

`enum color { red, yellow, green }; `不限定作用域。

###### decltype用法

推导出**表达式**类型：`decltype(23 + 2.3) ff`定义一个 `double` 类型的变量 ff。

- 重用匿名类型。
- 与using/typedef合用，用于定义类型。
- 泛型编程中结合auto，用于追踪函数的返回值类型。

###### 右值引用

右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

###### 纯虚函数

纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。

```cpp
virtual int A() = 0;
```

###### 虚函数、纯虚函数

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- 带**纯虚函数**的类叫**抽象类**，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
- 虚基类是虚继承中的基类。

###### 虚继承

虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

虚继承当中在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化。

为了保证**虚基类**在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。

###### malloc、calloc、realloc、alloca

- malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
- calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
- realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
- alloca：在栈上申请内存。程序在**出栈**的时候，会**自动释放内存**。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

###### 如何定义一个只能在堆上（栈上）生成对象的类？

- 只能在堆上

方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

- 只能在栈上

方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

###### 智能指针

1. shared_ptr
2. unique_ptr
3. weak_ptr
4. auto_ptr（被 C++11 弃用）

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

###### 运行时类型信息 (RTTI)

dynamic_cast

- 用于多态类型的转换

typeid

- typeid 运算符允许在运行时确定对象的类型
- type_id 返回一个 type_info 对象的引用
- 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
- 只能获取对象的实际类型

type_info

- type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。



## Caution & Tips

- [ ] 看一下 struct 写法，尤其构造函数和初始化列表，为了手写 struct 做准备。
- [ ] 记住万能头文件 `include<bits/stdc++.h>`。

